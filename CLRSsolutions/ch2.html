<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - ch2</title>
    <link href="../style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  </head>
  <body>

      <nav>
        <a href="../"> HOME </a>
        <span> / </span>
        <a href="../CV.html"> CV </a>
        <span> / </span>
        <a href="../blog.html"> BLOG </a>
        <span> / </span>
        <a href="https://github.com/danielbarter"> GITHUB </a> 
      </nav>

    <h1 id="clrs-chapter-2">CLRS Chapter 2</h1>
<p><strong>2.1-1.</strong> The bar <code>|</code> denotes the boundry between sorted and unsorted. The <code>*</code> denotes the spot for the next insertion.</p>
<pre class="algorithm"><code>31,41,59,26,41,58 -&gt; 31,*|41,59,26,41,58
                  -&gt; 31,41,*|59,26,41,58
                  -&gt; *,31,41,59|26,41,58
                  -&gt; 26,31,41,*,59|41,58
                  -&gt; 26,41,41,51,*,59|58
-&gt; 26,41,41,51,58,59</code></pre>
<p><strong>2.1-2.</strong> Given that we are using a computation model similar to that of C, we can pass function pointers as arguments to procedures.</p>
<pre class="algorithm"><code>insertionSort(A,f)
  for j = 2 to A.length
  key = A[j]
  i = j - 1
  while i &gt; 0 and f(key,A[i])
    A[i+1] = A[i]
    i = i - 1
  A[i+1] = key</code></pre>
<p>We are assuming that <code>f</code> is a procedure which takes two numbers and returns true or false. We can get the desired effect using the following procedures:</p>
<pre class="algorithm"><code>// for normal insertion sort
f(x,y)
  return (x &lt; y)
  
// for sorting into nonincreasing order
g(x,y)
  return (y &lt; x)</code></pre>
<p><strong>2.1-3.</strong> Here is the procedure:</p>
<pre class="algorithm"><code>linearSearch(A,v)
  for i = 1 to A.length
    if A[i] == v 
    then return i
  return nil</code></pre>
<p>If the list doesn't contain <code>v</code>, then the if condition is never satisfied, so we return <code>nil</code>. If the list does contain <code>v</code>, then after the first time <code>A[i] == v</code>, we return <code>i</code>.</p>
<p><strong>2.1-4.</strong> First, lets state the problem formally. <strong>Input:</strong> Two length <span class="math inline">\(n\)</span> arrays <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> of binary digits. <strong>Output:</strong> A length <span class="math inline">\(n+1\)</span> array <span class="math inline">\(C\)</span> which contains the sum.</p>
<pre class="algorithm"><code>// binaryPlus(x,y,z) is a procedure which adds the binary digits x and y. It returns c,s which is the carry and the sum.

binaryAdd(A,B,C,n)
  c = 0
  for i = 1 to n
    c,s = binaryPlus(A[i],B[i],c)
    C[i] = s
  C[n+1] = c</code></pre>
<p><strong>2.2-1.</strong> <span class="math inline">\(\Theta(n^3)\)</span></p>
<p><strong>2.2-2.</strong> Here is the pseudocode for selection sort:</p>
<pre class="algorithm"><code>// n is the length of the array
selectionSort(A,n)
  for i = 1 to (n - 1)
    j = minimumIndex(A[i:],n-i+1)
    swap(&amp;A[i],&amp;A[j])
    
minimumIndex(B,m)
  min = 1
  for k = 2 to m
    if B[k] &lt; B[min]
      min = k
  return min
  
// p and q are pointers
// constant time
swap(p,q)
  x = *p
  *p = *q
  *q = x</code></pre>
<p>Since repeatedly picking the index with the smallest value produces an increasing sequence, once selectionSort finishes, the array will be sorted. Since the last element is never picked, it is larger than all the others. The procedure swap has runtime <span class="math inline">\(\Theta(1)\)</span> and the procedure minimumIndex has runtime <span class="math inline">\(\Theta(m)\)</span>. Both the best and worst case runtimes are <span class="math inline">\(\Theta(n^2)\)</span>.</p>
<p><strong>2.2-3.</strong> Suppose that the array has length <span class="math inline">\(n\)</span>. If the value is in position <span class="math inline">\(k\)</span>, then the procedure returns in time <span class="math inline">\(\Theta(k)\)</span>. Assuming that each position has probability <span class="math inline">\(1/n\)</span>, the expected runtime is <span class="math inline">\(\Theta(n)\)</span>. The worst case runtime is also <span class="math inline">\(\Theta(n)\)</span>.</p>
<p><strong>2.2-4.</strong> Take for example selection sort. As written above, the best case runtime is <span class="math inline">\(\Theta(n^2)\)</span>. If we first check to see if the array is already sorted, the best case runtime becomes <span class="math inline">\(\Theta(n)\)</span>.</p>
<p><strong>2.3-1.</strong></p>
<pre class="algorithm"><code>           3,9,26,38,41,49,52,57
           /                  \
    3,26,41,52                9,38,49,57
     /       \                 /       \
 3,41        26,52        38,57        9,49
 /  \         /  \         / \         /  \
3   41      52   26      38   57      9   49</code></pre>
<p><strong>2.3-2.</strong></p>
<pre class="algorithm"><code>merge(A,p,q,r)
  n1 = q - p + 1
  n2 = r - q
  let L[1..n1] and R[1..n2] be new arrays

  for i = 1 to n1
    L[i] = A[p+i-1]
  for j = 1 ro n2
    R[j] = A[q+j]

  i = 1
  j = 1

  for k = p to r
    case 
      i == n1 + 1
        A[k] = R[j]
        j = j + 1
        break
      j == n2 + 1
        A[k] = L[i]
        i = i + 1
        break
      L[i] &lt;= R[j]
        A[k] = L[i]
        i = i + 1
        break
      else
        A[k] = R[j]
        j = j + 1
        break</code></pre>
<p><strong>2.3-3.</strong> This is true because <span class="math inline">\(T(n) = 2 T(n/2^k) + kn\)</span>.</p>
<p><strong>2.3-4.</strong> First here is a procedure for inserting a value into a sorted list:</p>
<pre class="algorithm"><code>// A is an array with n elements
// supposing that A[1..p] is sorted, insert takes A[p+1] and fits it into A[1..p] so that the result A[1..p+1] is sorted.

insert(A,p)
  v = A[p+1]
  i = p
  while i &gt; 0 and key &lt; A[i]
    A[i+1] = A[i]
    i = i - 1
  A[i+1] = v</code></pre>
<p>The procedure insert has worst case running time <span class="math inline">\(\Theta(p)\)</span>.</p>
<pre class="algorithm"><code>insertionSortRec(A,n)
   if n &gt; 1
     insertionSortRec(A,n-1)
     insert(A,n-1)</code></pre>
<p>If <span class="math inline">\(T(n)\)</span> is the worst case running time for insertionSortRec, then we have something like <span class="math inline">\(T(n) = T(n-1) + n\)</span> which gives us <span class="math inline">\(T(n) = n^2\)</span>. This procedure also allocates <span class="math inline">\(n\)</span> stack frames, so in terms of space complexity, it is strictly worse than the iterative version which runs in constant space.</p>
<p><strong>2.3-5.</strong> Here is one possible algorithm:</p>
<pre class="algorithm"><code>// binarySearch requires the array A to be sorted.
// we seach for the value between indexes p and q inclusive.
binarySearch(A,p,q,v)
  if p == q
    if A[p] == v
      return p
    else
      return nil
  else
    r1 = binarySearch(A,p,floor((p+q)/2),v)
    r2 = binarySearch(A,floor((p+q)/2) + 1,q,v)
  
  return seq(r1,r2)
  
seq(r1,r2)
  if r1 == nil
    return r2
  else
    return r1</code></pre>
<p>Let <span class="math inline">\(T(n)\)</span> be the worst case runtime of <code>binarySearch(A,1,n,v)</code>. Then roughly, we have <span class="math inline">\(T(n) = 2 T(n/2) + c\)</span> and <span class="math inline">\(T(n) \geq cn\)</span>, so this is not good. A better approach is</p>
<pre class="algorithm"><code>binarySearch(A,p,q,v)
  if p == q
    if A[p] == v
      return p
    else
      return nil
  
  m = floor((p+q)/2)
  if v &lt;= A[m]
    return binarySearch(A,p,m,v)
  else
    return binarySearch(A,m + 1,q,v)</code></pre>
<p>Then we have <span class="math inline">\(T(n) = T(n/2) + 1\)</span> which gives <span class="math inline">\(T(n) = \Theta(\log n)\)</span></p>
<p><strong>2.3-6.</strong> I don't see an obvious way to do this. The issue is that binary search will allow us to find the correct spot in logarithmic time, but it will still take linear time to build the new array with the value inserted.</p>
<p><strong>2.3-7.</strong> Suppose that the integers are presented to us in an array <code>A</code> and we want to decide if <code>x</code> is the sum of two elements in <code>A</code>.</p>
<pre class="algorithm"><code>sumOfTwo(A,x)
  mergeSort(A,1,A.length)
  for i = 1 to (A.length - 1)
    maybej = binarySearch(A,i+1,A.length,x - A[i])
    if j != nil
      return i,j
  return nil</code></pre>
<p>If <span class="math inline">\(n\)</span> is the size of the array, then <code>mergeSort</code> has worst case runtime <span class="math inline">\(\Theta(n \log n)\)</span> and the loop has worst case runtime <span class="math inline">\(O(\log n + \log (n-1) + ...)\)</span>. Therefore <code>sumofTwo</code> has worst case runtime <span class="math inline">\(\Theta(n \log n)\)</span>.</p>
<p><strong>2-1-a.</strong> Firstly, it is easy to modify the <code>insertionSort</code> procedure so that it takes a start and end index in the array and sorts the corresponding sub array. Also for simplicity, we assume that k divides n. Then we have</p>
<pre class="algorithm"><code>insertionSortLeaves(A,k,n)
  for i = 1 to (n/k)
    insertionSort(A,(i-1)*k + 1,i*k)</code></pre>
<p>The worst case run time for <code>insertionSortLeaves</code> is <span class="math inline">\(\Theta(k^2 * n/k ) = \Theta(nk)\)</span>.</p>
<p><strong>2-1-b.</strong> Inorder to merge the already sorted chunks, we modify the <code>mergeSort</code> algorithm to use box numbers instead of array indexes:</p>
<pre class="algorithm"><code>// p and q are box numbers, not indexes
mergeLeaves(A,k,p,q)
  if p &lt; q
    m = floor((p + q)/2)
    mergeLeaves(A,k,p,m)
    mergeLeaves(A,k,m+1,q)
    merge(A,(p-1)*k+1,q*k)</code></pre>
<p>The worst case runtime satisfies <span class="math inline">\(T(n,k) = 2 T(n/2,k) + n\)</span> which implies that <span class="math inline">\(T(n,k) = n * \log(n/k)\)</span>.</p>
<p><strong>2-1-c.</strong> Since <span class="math inline">\(nk + n \log(n/k) = n (k - \log k) + n \log n\)</span>, if we take <span class="math inline">\(k = O(\log n)\)</span>, then we will have the same asymptotic runtime as merge sort.</p>
<p><strong>2-1-d.</strong> With our current analysis we have no understanding of the lower order terms or constants in the worst case runtime. In practice, <span class="math inline">\(k\)</span> should be chosen empirically, guided by <span class="math inline">\(k= O(\log n)\)</span>.</p>

  </body>
</html>
