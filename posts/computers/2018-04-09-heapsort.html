<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - heapsort</title>
    <link href="../../style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <nav>
<a href="../../"> HOME </a>
<span> / </span>
<a href="../../CV.html"> CV </a>
<span> / </span>
<a href="../../publickey.html"> PUBKEY </a>
<span> / </span>
<a href="../../mix.html"> MIX1010 </a>
<span> / </span>
<a href="../../tableau.html"> TABLEAU </a>
</nav>

<h1 id="heapsort">Heapsort</h1>
<p>In the <a href="2018-04-01-insertion-and-merge-sort.html">last post</a> we implemented the insertion and merge sort algorithms. Insertion sort has time complexity <span class="math inline">\(O(L^2)\)</span> and space complexity <span class="math inline">\(O(1)\)</span>. Merge sort has time complexity <span class="math inline">\(O(L \log L)\)</span> and space complexity <span class="math inline">\(O(L)\)</span>. It is natural to ask if there is an array sorting algorithm with time complexity <span class="math inline">\(O(L \log L)\)</span> and space complexity <span class="math inline">\(O(1)\)</span>. The heapsort algorithm has these properties, and we shall implement it in this post. All this code and some testing code can be <a href="../../CALGO/max_binary_heap/max_binary_heap.c">found</a> <a href="../../CALGO/max_binary_heap/test.c">here</a>.</p>
<h3 id="max-binary-heaps">Max Binary Heaps</h3>
<p>We can encode a complete binary tree using an array as follows: <img src="../../img/binary_heap_storage.svg" style="width: 800px; display: block; margin: 0 auto;" /> If <span class="math inline">\(i\)</span> is an index, then the parent index is <span class="math inline">\(\left \lfloor i/2 \right \rfloor\)</span>, the left child index is <span class="math inline">\(2i\)</span> and the right child index is <span class="math inline">\(2i+1\)</span>. This is the fundamental idea behind the max binary heap data structure which we implement as follows:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="kw">struct</span>
{
  <span class="co">/* array of pointers */</span>
  <span class="dt">void</span> **array;

  <span class="co">/* length of array */</span>
  <span class="dt">int</span> length;

  <span class="co">/*</span>
<span class="co">    length of heap. Not all elements in the array are part of the heap.</span>
<span class="co">    The array is array[1..length].</span>
<span class="co">    The heap is array[1..heap_size].</span>
<span class="co">    When heap_size &lt; length, then array[heap_size + 1..length] is extra space.</span>
<span class="co">   */</span>
  <span class="dt">int</span> heap_size;

  <span class="co">/*</span>
<span class="co">    compare points to a procedure which computes *ptr1 &lt; *ptr2</span>
<span class="co">   */</span>
  <span class="dt">int</span> (*compare)(<span class="dt">void</span> *ptr1, <span class="dt">void</span> *ptr2);


} heap;</code></pre></div>
<p>The data structure consists of an array <span class="math inline">\(A\)</span> of objects, its length <span class="math inline">\(L\)</span>, the length of the heap <span class="math inline">\(H\)</span> and a procedure for comparing objects in the array. Not every element in the array is part of the heap. The heap consists of the entries <span class="math inline">\(A[1..H]\)</span> and the entries <span class="math inline">\(A[H+1..L]\)</span> are extra space. In <a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">CLRS</a>, arrays are indexed starting at <span class="math inline">\(1\)</span>, and for heaps, this makes the bijection between nodes in a complete binary tree and array entries more transparent. For this reason, we don't directly index <code>array</code>. We use getters and setters instead:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">inline</span> <span class="dt">void</span> *get(heap *h, <span class="dt">int</span> i){ <span class="cf">return</span> h-&gt;array[i-<span class="dv">1</span>];}
<span class="kw">inline</span> <span class="dt">void</span> *set(heap *h, <span class="dt">int</span> i, <span class="dt">void</span> *ptr){ <span class="cf">return</span> (h-&gt;array[i-<span class="dv">1</span>]) = ptr;}</code></pre></div>
<p>When heaps are implemented in this way, the tree operations are very simple:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">inline</span> <span class="dt">int</span> parent(<span class="dt">int</span> i){ <span class="cf">return</span> i/<span class="dv">2</span>;}
<span class="kw">inline</span> <span class="dt">int</span> left(<span class="dt">int</span> i){ <span class="cf">return</span> <span class="dv">2</span>*i;}
<span class="kw">inline</span> <span class="dt">int</span> right(<span class="dt">int</span> i){ <span class="cf">return</span> <span class="dv">2</span>*i + <span class="dv">1</span>;}</code></pre></div>
<p>One of the key properties we want a max binary heap to satisfy is the max property: For all the objects in <span class="math inline">\(A[1..H]\)</span>, we want <span class="math inline">\(A[{\rm parent}(i)] \geq A[i]\)</span>. Almost all our computational effort is spent making sure that this property holds using the <code>max_heapify</code> procedure:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> max_heapify(heap *h, <span class="dt">int</span> i)
{
  <span class="dt">int</span> l = left(i);
  <span class="dt">int</span> r = right(i);

  <span class="dt">int</span> largest;
  <span class="dt">void</span> *temp;

  <span class="co">/* determine which is larger out of A[i], A[l], A[r].  */</span>
  <span class="cf">if</span> ((l &lt;= h-&gt;heap_size) &amp;&amp; ( (*h-&gt;compare)( get(h,i), get(h,l) ) ) )
    largest = l;
  <span class="cf">else</span> largest = i;

  <span class="cf">if</span> ((r &lt;= h-&gt;heap_size)  &amp;&amp; ( (*h-&gt;compare)( get(h,largest), get(h,r) ) ) )
    largest = r;


  <span class="co">/* swap A[i] and A[largest] */</span>
  <span class="cf">if</span> (largest != i)
    {
      temp = get(h,largest);
      set(h, largest, get(h,i));
      set(h, i, temp);
      max_heapify(h,largest);
    }
}</code></pre></div>
<p>The procedure <code>max_heapify</code> assumes that the binary trees rooted at <code>left(i)</code> and <code>right(i)</code> satisfy the max property, but the object contained at index <span class="math inline">\(i\)</span> might be smaller than its children. It lets <span class="math inline">\(A[i]\)</span> float down until the whole tree rooted at index <span class="math inline">\(i\)</span> satisfies the max property. Since the tree rooted at <span class="math inline">\(i\)</span> has height <span class="math inline">\(\log_2 (H/i)\)</span>, the time complexity of this procedure is <span class="math inline">\(O(\log(H/i))\)</span>. The space complexity is more subtle. The key point is that <code>max_heapify</code> is <a href="https://en.wikipedia.org/wiki/Tail_call">tail recursive</a>, so an optimizing compiler will replace the recursion with a loop. Assuming that this is the case, the stack doesn't grow while <code>max_heapify</code> is executing and only four local variables are instantiated. Therefore, the space complexity for running <code>max_heapify</code> is <span class="math inline">\(O(1)\)</span>.</p>
<p>The procedure <code>build_max_heap</code> constructs a heap satisfying the max property from an array:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> build_max_heap(heap *h)
{
  <span class="dt">int</span> i;

  h-&gt;heap_size = h-&gt;length;

  <span class="cf">for</span> (i = h-&gt;length/<span class="dv">2</span>; i &gt;= <span class="dv">1</span>;i--)
    max_heapify(h,i);
}</code></pre></div>
<p>It expects a heap data structure where the data is contained in <code>h.array</code> and the heap size is zero. It then loops through all the nodes which are not leaves and applies the <code>max_heapify</code> procedure. The loop order ensures that when we apply <code>max_heapify</code> at index <code>i</code>, the trees rooted at <code>left(i)</code> and <code>right(i)</code> satisfy the heap property. The time complexity for <code>build_max_heap</code> is proportional to <span class="math display">\[\sum_{i=1}^{H/2} \log(H/i) = H \log (H) / 2 - \sum_{i=1}^{H/2} \log (i)\approx H \log (H) / 2- H \log (H/2) / 2 = H/2.\]</span> Therefore, the time complexity for <code>build_max_heap</code> is <span class="math inline">\(O(H)\)</span> where <span class="math inline">\(H\)</span> is the heap size. The space complexity is <span class="math inline">\(O(1)\)</span>.</p>
<h3 id="heapsort-1">Heapsort</h3>
<p>We can use heaps to sort an array:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> heapsort(heap *h)
{
  <span class="dt">int</span> i;
  <span class="dt">void</span> *temp;
  build_max_heap(h);
  <span class="cf">for</span> (i = h-&gt;length; i &gt;= <span class="dv">2</span>; i--)
    {
      temp = get(h,<span class="dv">1</span>);
      set(h,<span class="dv">1</span>,get(h,i));
      set(h,i,temp);
      h-&gt;heap_size--;
      max_heapify(h,<span class="dv">1</span>);
    }
}</code></pre></div>
<p>This procedure first runs <code>build_max_heap</code>. When the procedure returns, the largest element in the array is at the root. Then we swap the root with the last element of the array and decrease the heap size by one. At this point, the two trees rooted at <span class="math inline">\(2\)</span> and <span class="math inline">\(3\)</span> still satisfy the max heap property, so we can run <code>max_heapify</code> which brings the second largest element into the root position. If <span class="math inline">\(L\)</span> is the length of the list, then the time complexity of heap sort is <span class="math display">\[
L + \log L + \log(L-1) + \dots + \log 2 = O(L \log L)
\]</span> Since the space complexity for <code>max_heapify</code> and <code>build_max_heap</code> are <span class="math inline">\(O(1)\)</span>, the space complexity for <code>heapsort</code> is also <span class="math inline">\(O(1)\)</span>.</p>


  </body>
</html>
