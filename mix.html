<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - mix</title>
    <link href="./style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script src="mix.js"></script>

  </head>
  <body>

      <nav>
        <a href="./"> HOME </a>
        <span> / </span>
        <a href="./CV.html"> CV </a>
        <span> / </span>
        <a href="./blog.html"> BLOG </a>
        <span> / </span>
        <a href="./mix.html"> MIX1010 </a> 
      </nav>

    <h1 id="mix-1010">MIX 1010</h1>
<p>This is a simulator for Knuth's MIX machine from the book <a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">Art of Computer Programming</a>. We use the identifier 1010 because this machine is slightly different from MIX 1009. We encode masks using binary and there is no division or multiplication instructions. A detailed readme and instruction list can be found on <a href="https://github.com/danielbarter/elm-mix">github</a>.</p>
<div id="mix1">

</div>
<script>
    var node = document.getElementById('mix1');
    var app = Elm.Main.embed(node);
</script>
<p>Statements in the assembler language look like <strong>(:label) (/mask) (instruction) (relative address) (+index)</strong>. Instuctions in memory look like <strong>address(:label) (/mask) (instruction) (address) (+index)</strong>. Here is an example multiplication routine:</p>
<pre class="algorithm"><code># multiplication routine
:start LDA y
JAZ end
DECA 1
STA y
LDA x
ADD s
STA s
JMP start
:end LDA s
HLT

# data
:s 0
:x 5
:y 6</code></pre>
<p>Here is a variant of this routine which is self modifying:</p>
<pre class="algorithm"><code># modify the instruction located at end
LDA end
INCA 7
STA end

#multiplication routine
:start LDA y
JAZ end
DECA 1
STA y
LDA x
ADD s
STA s
JMP start
:end LDA s
HLT

# data
:s 0
:x 5
:y 6</code></pre>
<p>Here is an example where we loop through a zero terminated array and increment each entry by 1:</p>
<pre class="algorithm"><code>#routine

:start LDA x +1
JAZ end
INCA 1
STA x +1
INC1 1
JMP start

:end HLT


#data
:x 7
-1
2
4
1
0</code></pre>
<p>Here is an example where we compute the maximum in an array of numbers.</p>
<pre class="algorithm"><code>ENT1 x
LD2 x_length
:loop J2Z end
CMPA 0 +1
JL update
:t INC1 1
DEC2 1
JMP loop

:update LDA 0 +1
JMP t

:end HLT

:x_length 9
:x 8
4
-3
2
1
5
1
2
10</code></pre>
<p>Here is an example where we add up all the numbers on a stack:</p>
<pre class="algorithm"><code># adding up all the numbers on the stack.

# we maintain the stack pointer in I6
INC6 stack_top 
JMP add
JMP add
JMP add
JMP add
JMP add
JMP add
LDA 0 +6
HLT

# addition routine
:add STJ add_return_adr
JSJ add_start
:add_return_adr
:add_start LDA 0 +6
ADD -1 +6
DEC6 1
STA 0 +6
LD1 add_return_adr
JMP 0 +1

# stack bottom
2
10
8
5
8
4
:stack_top 5</code></pre>
<p>We can expand this example out into a programmable stack calculator with addition and multiplication operations:</p>
<pre class="algorithm"><code># programmable stack calculator.

# we maintain the stack pointer in I6
INC6 stack_top 

###################################
########## start code #############
###################################

JMP push
4
JMP push
5
JMP mult
JMP push
2
JMP mult
JMP push
2
JMP add


###################################
########### end code ##############
###################################



LDA 0 +6
HLT

# push routine
:push STJ push_return_adr
JSJ push_start
:push_return_adr
:push_start INC6 1
LD1 push_return_adr
LDA 0 +1
STA 0 +6
JMP 1 +1

# addition routine
:add STJ add_return_adr
JSJ add_start
:add_return_adr
:add_start LDA 0 +6
ADD -1 +6
DEC6 1
STA 0 +6
LD1 add_return_adr
JMP 0 +1


# multiplication routine
:mult STJ mult_return_adr
STZ s
JSJ mult_start
:mult_return_adr
:s 
:mult_start LDA 0 +6
CMPA -1 +6
JGE loop
LDX -1 +6
STA -1 +6
STX 0 +6
:loop LDA -1 +6
JAZ mult_end
DECA 1
STA -1 +6
LDA 0 +6
ADD s
STA s
JMP loop
:mult_end DEC6 1
LDA s
STA 0 +6
LD1 mult_return_adr
JMP 0 +1

#stack bottom
:stack_top </code></pre>

  </body>
</html>
