<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - ch1</title>
    <link href="../style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  </head>
  <body>

      <nav>
        <a href="../"> HOME </a>
        <span> / </span>
        <a href="../CV.html"> CV </a>
        <span> / </span>
        <a href="../blog.html"> BLOG </a>
        <span> / </span>
        <a href="https://github.com/danielbarter"> GITHUB </a> 
      </nav>

    <h1 id="clrs-chapter-1">CLRS Chapter 1</h1>
<p><strong>1.1-1.</strong> Alphabetizing student exam papers prior to recording grades into the grade book, where the students appear in alphabetical order.</p>
<p><strong>1.1-2.</strong> Heap usage. Maximum stack depth.</p>
<p><strong>1.1-3.</strong> A <em>linked list</em> consists of a collection of pairs <span class="math inline">\((d,p)\)</span> where <span class="math inline">\(d\)</span> is a piece of data and <span class="math inline">\(p\)</span> is a pointer to the next pair. For example, we might have <span class="math display">\[ l \to (d_1,p_1) \quad p_1 \to (d_2,p_2) \quad p_2 \to (d_3,0) \]</span> One strength of linked lists is that we don't need to store the nodes in adjacent heap locations which is useful when adding elements to the list. One disadvantage is that if you have the pointer <span class="math inline">\(l\)</span> and you want to access the last element of the list, you need to traverse every node of the list.</p>
<p><strong>1.1-4.</strong> Both the travelling salesman and shortest parth problem take a graph as input and return paths in the input graph. The travelling salesman problem involves finding the shortest path which visits each vertex and the shortest path problem involves finding the shortest path between two specified verticies.</p>
<p><strong>1.1-5.</strong> In any problem where loss is proportional to runtime, only the best solution will do. On the otherhand, if loss does not depend on runtime, then finding the fastest algorithm is not as important.</p>
<p><strong>1.2-1.</strong> Face recognition in photo sharing software. The software should automatically recognise faces in images for the user to tag which makes sharing easier.</p>
<p><strong>1.2-2.</strong> We have <span class="math inline">\(8 n^2 &gt; 64 n \log_2 n\)</span> when <span class="math inline">\(n &gt; 42\)</span>.</p>
<p><strong>1.2-3.</strong> We have <span class="math inline">\(2^n &gt; 100 n^2\)</span> when <span class="math inline">\(n &gt; 15\)</span>.</p>
<p><strong>1.1.</strong> First we roughly convert the time units into microseconds. Also, our logarithms are base 10 and we discard the non leading terms in the base 10 expansion.</p>
<pre class="algorithm"><code>| time (ms)  |  10^6       |  10^7       |  10^9       |  10^{10}       |  10^{12}       |  10^{13}       |  10^{15}       |
|------------|-------------|-------------|-------------|----------------|----------------|----------------|----------------|
|  \log n    |  10^{10^6}  |  10^{10^7}  | $10^{10^9}  |  10^{10^{10}}  |  10^{10^{12}}  |  10^{10^{13}}  |  10^{10^{15}}  |
|  \sqrt{n}  |  10^{12}    |  10^{14}    | $10^{18}    |  10^{20}       |  10^{24}       |  10^{26}       |  10^{30}       |
|  n         |  10^{6}     |  10^{7}     | $10^{9}     |  10^{10}       |  10^{12}       |  10^{13}       |  10^{15}       |
|  n \log n  |  10^5       |  10^6       | $10^8       |  10^9          |  10^{11}       |  10^{12}       |  10^{14}       |
|  n^2       |  10^3       |  10^3       | $10^4       |  10^5          |  10^6          |  10^6          |  10^7          |
|  n^3       |  10^2       |  10^2       | $10^3       |  10^3          |  10^4          |  10^4          |  10^5          |
|  10^n      |  6          |  7          |  9          |  10            |  12            |  13            |  15            |
|  n!        |  10         |  11         |  13         |  14            |  15            |  16            |  17            |</code></pre>

  </body>
</html>
