<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - the shortest x64 linux hello world</title>
    <link href="../../style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <nav>
<a href="../../"> HOME </a>
<span> / </span>
<a href="../../CV.html"> CV </a>
<span> / </span>
<a href="../../publickey.html"> PUBKEY </a>
<span> / </span>
<a href="../../mix.html"> MIX1010 </a>
<span> / </span>
<a href="../../tableau.html"> TABLEAU </a>
</nav>

<h1 id="the-shortest-x64-linux-hello-world">The Shortest x64 Linux Hello World</h1>
<p>The first program that you write in a new language is Hello, world! In C, it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main (<span class="dt">void</span>) {
  puts(<span class="st">&quot;Hello, world!&quot;</span>);
  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>On my machine, using gcc to compile, this code produces an executable that is 8376 bytes long! Most of those bytes are part of the C runtime and there is a lot of useful functionality there, but there is a shorter way. When Linux loads an executable, it is expected to be an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> file. Roughly speaking, ELF files consist of a list of objects organized into sections like <code>.text</code> which contains code objects and <code>.data</code> which contains data objects. To print &quot;Hello, world!&quot;, we need two objects: the code which executes a print system call and the string &quot;Hello, world!&quot;. We can write an assembly program that specifies exactly these objects:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">  .intel_syntax noprefix        # specify the assembly language


  .text                         # start of text <span class="bu">section</span>


  .globl _start                 # _start object metadata
  .type _start, @function       # _start object metadata
<span class="fu">_start:</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">1</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">1</span>
  <span class="bu">lea</span> <span class="kw">rsi</span>, hello_string
  <span class="bu">mov</span> <span class="kw">rdx</span>, <span class="dv">14</span>
  <span class="bu">syscall</span>                       # sys_write(<span class="dv">1</span>,string_<span class="dv">1</span>,<span class="dv">14</span>)<span class="co">;</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">60</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">0</span>
  <span class="bu">syscall</span>                       # sys_exit(<span class="dv">0</span>)<span class="co">;</span>
  .size _start, .-_start        # _start object metadata. <span class="st">'.'</span> evaluates to current location


  .<span class="bu">data</span>                         # start of <span class="bu">data</span> <span class="bu">section</span>


  .globl hello_string           # string_<span class="dv">1</span> object metadata
  .type hello_string, @object   # string_<span class="dv">1</span> object metadata
<span class="fu">hello_string:</span>
  .string <span class="st">&quot;Hello, world!\n&quot;</span>
  .size hello_string, <span class="dv">14</span>        # string_<span class="dv">1</span> object metadata</code></pre></div>
<p>This code specifies exactly two objects, <code>_start</code>, a code object which executes a write system call and then an exit system call and <code>hello_string</code> which contains the string to print. If we run <code>as hello.s -o hello.o; ld hello.o -o hello.elf</code>, the resulting executable behaves exactly how it should and it is only 936 bytes long, about a 10th of the size!</p>
<h3 id="splitting-things-up">splitting things up</h3>
<p>If you are writing a lot of assembly, it is useful to split your objects among several different files. Instead of a single file for our hello world program, we could split it into two different files:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">  .<span class="dt">file</span> <span class="st">&quot;print.s&quot;</span>
  .intel_syntax noprefix

  .text

  .globl _start
  .type _start, @function
<span class="fu">_start:</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">1</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">1</span>
  <span class="bu">lea</span> <span class="kw">rsi</span>, hello_string
  <span class="bu">mov</span> <span class="kw">rdx</span>, <span class="dv">14</span>
  <span class="bu">syscall</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">60</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">0</span>
  <span class="bu">syscall</span>
  .size _start, .-_start</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">  .<span class="dt">file</span> <span class="st">&quot;string.s&quot;</span>
  .intel_syntax noprefix

  .<span class="bu">data</span>

  .globl hello_string
  .type hello_string, @object
<span class="fu">hello_string:</span>
  .string <span class="st">&quot;Hello, world!\n&quot;</span>
  .size hello_string, <span class="dv">14</span></code></pre></div>
<p>We can produce exactly the same executable as before if we run <code>as print.s -o print.o; as string.s -o string.o; ld *.o -o hello.elf</code>.</p>
<h3 id="linking-your-assembly-into-a-c-file">Linking your assembly into a C file</h3>
<p>Maybe we still want to print hello world in the smallest way possible, but we don't want to throw away the C runtime. In that case, we want to run our assembly from inside a C program. Given the following three files:</p>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">  .<span class="dt">file</span> <span class="st">&quot;print.s&quot;</span>
  .intel_syntax noprefix

  .text

  .globl print
  .type print, @function
<span class="fu">print:</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">1</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">1</span>
  <span class="bu">lea</span> <span class="kw">rsi</span>, hello_string
  <span class="bu">mov</span> <span class="kw">rdx</span>, <span class="dv">14</span>
  <span class="bu">syscall</span>
  <span class="bu">mov</span> <span class="kw">rax</span>, <span class="dv">60</span>
  <span class="bu">mov</span> <span class="kw">rdi</span>, <span class="dv">0</span>
  <span class="bu">syscall</span>
  .size print, .-print</code></pre></div>
<div class="sourceCode"><pre class="sourceCode asm"><code class="sourceCode fasm">  .<span class="dt">file</span> <span class="st">&quot;string.s&quot;</span>
  .intel_syntax noprefix

  .<span class="bu">data</span>

  .globl hello_string
  .type hello_string, @object
<span class="fu">hello_string:</span>
  .string <span class="st">&quot;Hello, world!\n&quot;</span>
  .size hello_string, <span class="dv">14</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// main.c</span>
<span class="dt">void</span> print(<span class="dt">void</span>);

<span class="dt">int</span> main (<span class="dt">void</span>) {
  print();
}</code></pre></div>
<p>If we run <code>gcc -no-pie main.c print.s string.s -o main.elf</code>, then we get an executable which still has the C runtime, but prints hello world in the smallest possible way. The flag <code>-no-pie</code> is required because by default, gcc produces position indipendent code, but we need to place our assembly objects somewhere in memory!</p>


  </body>
</html>
