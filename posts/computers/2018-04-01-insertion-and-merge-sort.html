<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - insertion and merge sort</title>
    <link href="../../style.css" rel="stylesheet">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <nav>
<a href="../../"> HOME </a>
<span> / </span>
<a href="../../CV.html"> CV </a>
<span> / </span>
<a href="../../publickey.html"> PUBKEY </a>
<span> / </span>
<a href="../../blog.html"> BLOG </a>
<span> / </span>
<a href="../../mix.html"> MIX1010 </a>
<span> / </span>
<a href="../../tableau.html"> TABLEAU </a>
</nav>

<h1 id="insertion-and-merge-sort">Insertion and Merge Sort</h1>
<p>Sorting an array is one of the cornerstone problems in computer science. In this post, we explore some algorithms for this task. All the code in this post can be found <a href="../../CALGO/array_sort.c">here</a>. The algorithms are reproduced below. The linked source file also contains some code for testing the algorithms.</p>
<h3 id="insertion-sort">Insertion Sort</h3>
<p>Insertion sort begins with an array <span class="math inline">\(A\)</span>. Suppose that <span class="math inline">\(A\)</span> is sorted up to index <span class="math inline">\(i\)</span>. If we insert <span class="math inline">\(A_{i+1}\)</span> into the correct place, then <span class="math inline">\(A\)</span> will be sorted up to index <span class="math inline">\(i+1\)</span>. This allows us to inductively sort the array. Here is a C procedure which does this:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> insertion_sort ( <span class="dt">int</span> *array, <span class="dt">int</span> length )

<span class="co">/*</span>

<span class="co">  array is a pointer to the first element of the array</span>
<span class="co">  length is the length of the array</span>

<span class="co">*/</span>

{
  <span class="dt">int</span> j;          <span class="co">/* index of the next element to be inserted */</span>
  <span class="dt">int</span> i;          <span class="co">/* index for looping through the sorted part of array */</span>
  <span class="dt">int</span> element;    <span class="co">/* next element to be inserted */</span>

  <span class="cf">for</span> (j = <span class="dv">1</span>; j &lt; length; j++)
    {
      element = array[j];      <span class="co">/* store the element to be inserted */</span>
      i = j - <span class="dv">1</span>;               <span class="co">/* store the top index of the already sorted part */</span>
      <span class="cf">while</span> ( (i &gt;= <span class="dv">0</span>) &amp;&amp; (array[i] &gt; element) )
        <span class="co">/*</span>
<span class="co">          loop through the already sorted part</span>
<span class="co">          searching for where element needs to be inserted.</span>
<span class="co">          At the same time, we also move the parts bigger than element one</span>
<span class="co">          spot to the right.</span>
<span class="co">         */</span>
        {
          array[i+<span class="dv">1</span>] = array[i];
          i = i - <span class="dv">1</span>;
        }
      array[i+<span class="dv">1</span>] = element; <span class="co">/* slot element in */</span>
    }
}</code></pre></div>
<p>In terms of the length <span class="math inline">\(L\)</span> of the array, the space complexity of the algorithm is <span class="math inline">\(O(1)\)</span> and the time complexity is <span class="math inline">\(O(L^2)\)</span>.</p>
<h3 id="merge-sort">Merge Sort</h3>
<p>The merge sort algorithm recursively sorts the first half of the array, then recursively sorts the second half of the array and then merges the result together.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> merge ( <span class="dt">int</span> *array, <span class="dt">int</span> low, <span class="dt">int</span> middle, <span class="dt">int</span> high)
<span class="co">/*</span>

<span class="co">  array is a pointer to the first element of the array.</span>
<span class="co">  low, mid and high are indices in the array with low &lt;= mid &lt; high</span>
<span class="co">  the procedure assumes that array[low,mid] and array[mid+1,high] are sorted.</span>
<span class="co">  It merges them so that array[low,high] is sorted.</span>

<span class="co">*/</span>

{
  <span class="dt">int</span> l1 = middle - low + <span class="dv">1</span>;   <span class="co">/* length of first subarray */</span>
  <span class="dt">int</span> l2 = high - middle;      <span class="co">/* length of second subarray */</span>


  <span class="co">/*</span>
<span class="co">    allocating some temporary arrays on the stack.</span>
<span class="co">    this is going to limit the size the array which this procedure can work with.</span>
<span class="co">    If high - low is too large, we are going to overflow the stack.</span>

<span class="co">    Also, L and R are one entry bigger than the corresponding sub arrays.</span>
<span class="co">    This is because we put a very large token at the end to help us in the following computation.</span>
<span class="co">   */</span>
  <span class="dt">int</span> l[l1+<span class="dv">1</span>];
  <span class="dt">int</span> r[l2+<span class="dv">1</span>];

  <span class="dt">int</span> i;  <span class="co">/* index for L */</span>
  <span class="dt">int</span> j;  <span class="co">/* index for R */</span>
  <span class="dt">int</span> k;  <span class="co">/* index for array */</span>


  <span class="co">/* initializing L */</span>
  <span class="cf">for</span> (i = <span class="dv">0</span>; i &lt; l1; i++)
    l[i] = array[low+i];

  l[l1] = INT_MAX;

  <span class="co">/* initializing R */</span>
  <span class="cf">for</span> (j = <span class="dv">0</span>; j &lt; l2; j++)
    r[j] = array[middle + <span class="dv">1</span> + j];

  r[l2] = INT_MAX;

  i = j = <span class="dv">0</span>;

  <span class="cf">for</span> (k = low; k &lt;= high; k++)
    {
      <span class="cf">if</span> (l[i] &lt;= r[j])
        {
          array[k] = l[i];
          i = i + <span class="dv">1</span>;
        }
      <span class="cf">else</span>
        {
          array[k] = r[j];
          j = j + <span class="dv">1</span>;
        }
    }
}


<span class="dt">void</span> merge_sort_sub(<span class="dt">int</span> *array,<span class="dt">int</span> low,<span class="dt">int</span> high)
{
  <span class="dt">int</span> mid;

  <span class="cf">if</span> (low &lt; high)
    {
      mid = (low + high) / <span class="dv">2</span>;  <span class="co">/* integer division rounds down */</span>
      merge_sort_sub(array,low,mid);
      merge_sort_sub(array,mid+<span class="dv">1</span>,high);
      merge(array,low,mid,high);
    }
}

<span class="dt">void</span> merge_sort(<span class="dt">int</span> *array, <span class="dt">int</span> length)
{

  <span class="co">/* arguments two and three for merge_sort_sub must be indices for the array */</span> 
  merge_sort_sub(array,<span class="dv">0</span>,length-<span class="dv">1</span>);
}</code></pre></div>
<p>Let <span class="math inline">\(T(L)\)</span> be the run time of this algorithm. Then we have the relation <span class="math display">\[
T(L) = 2 T(L/2) + cn = 4 T(L/4) + 2 cn = \cdots \leq c' L \log_2 L.
\]</span> Therefore the time complexity of merge sort is <span class="math inline">\(O(L \log L)\)</span>. The space complexity of this procedure is a little more subtle. Since the <code>merge</code> procedure allocates the arrays <code>l</code> and <code>r</code> on the stack, we just need to understand how the stack grows and shrinks during execution. Let <span class="math inline">\(S(L)\)</span> be the maximum stack size during execution. Then <span class="math display">\[ S(L) \leq {\rm max} \{ S(L/2),cL \} \]</span> because <code>merge</code> allocates a whole copy of the array on the stack. This implies the stack grows by <span class="math inline">\(O(L)\)</span> during execution.</p>


  </body>
</html>
