<!DOCTYPE html>
<html>
  <head>
    <title> Daniel Barter - the tangent bundle</title>
    <link href="../../style.css" rel="stylesheet">

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>

  </head>
  <body>
    <nav>
<a href="../../"> HOME </a>
<span> / </span>
<a href="../../CV.html"> CV </a>
<span> / </span>
<a href="../../publickey.html"> PUBKEY </a>
<span> / </span>
<a href="../../mix.html"> MIX1010 </a>
<span> / </span>
<a href="../../tableau.html"> TABLEAU </a>
</nav>

<h1 id="the-tangent-bundle">The tangent bundle</h1>
<p>In <a href="2016-02-07-tangentspaces.html">the last post</a>, we defined the tangent space to a manifold at a point. That was the first step towards doing calculus on a manifold. In this post, we shall take the second step which is <em>bundling</em> the tangent spaces up into a single geometric object called the tangent bundle. We shall describe the tangent bundle in several different ways: As a vector bundle, as a locally free sheaf and as a sheaf of differential operators. Along the way we will see some more definitions from abstract sheaf theory.</p>
<h3 id="vector-bundles">Vector bundles</h3>
<p>Let <span class="math inline">\(X\)</span> be a manifold. Informally speaking, a vector bundle over <span class="math inline">\(X\)</span> is a family of vector spaces parameterized smoothly by the points in <span class="math inline">\(X\)</span>. This colloquial language does not suggest a definition. Here is a potential definition (which is incorrect): A vector bundle over <span class="math inline">\(X\)</span> consists of a manifold <span class="math inline">\(E\)</span> and a smooth map <span class="math inline">\(\pi : E \to X\)</span> such that each fiber <span class="math inline">\(\pi^{-1}(x) = \{ v \in E : \pi(v) = x\}\)</span> is a vector space. The main problem with this definition is that we are not forcing the vector space structure on the fibers to vary smoothly as we move around in <span class="math inline">\(X\)</span>. A second problem is that from this definition, there is no obvious way to describe a specific vector bundle structure. It should be easy to describe a vector bundle you are working with to your friends (assuming that you can describe the base manifold to them). Before we give the correct definition, we need some new terminology. Suppose that <span class="math inline">\(\pi : E \to X\)</span> is a smooth map. A vector bundle chart on <span class="math inline">\(E\)</span> consists of an open subset <span class="math inline">\(U \subseteq X\)</span> and a <a href="https://en.wikipedia.org/wiki/Diffeomorphism">diffeomorphism</a> <span class="math inline">\(\pi^{-1}(U) = U \times \mathbb{R}^r\)</span>. Now we can give the correct definition: A vector bundle over <span class="math inline">\(X\)</span> consists of a manifold <span class="math inline">\(E\)</span> and a smooth map <span class="math inline">\(\pi : E \to X\)</span> such that</p>
<ul>
<li>we can cover <span class="math inline">\(E\)</span> using vector bundle charts</li>
<li>given two vector bundle charts <span class="math inline">\(\pi^{-1}(U) = U \times \mathbb{R}^r\)</span> and <span class="math inline">\(\pi^{-1}(V) = V \times \mathbb{R}^r\)</span>, if <span class="math inline">\(U \cap V\)</span> is nonempty, then the change of coordinates from <span class="math inline">\(\pi^{-1}(U)\)</span> to <span class="math inline">\(\pi^{-1}(V)\)</span> is given by <span class="math display">\[(x,v) \mapsto (x,\phi(x)v)\]</span> where <span class="math inline">\(\phi : U \cap V \to {\rm GL}_r(\mathbb{R})\)</span> is a smooth map (this just means that each matrix entry is a smooth function of <span class="math inline">\(x \in U \cap V\)</span>)</li>
</ul>
<p>If the fibers are dimension <span class="math inline">\(r\)</span>, we call <span class="math inline">\(E\)</span> a vector bundle of rank <span class="math inline">\(r\)</span>. Let <span class="math inline">\(X\)</span> be a manifold. As a set, the tangent bundle is defined by <span class="math display">\[TX = \coprod_{x \in X}T_x X\]</span> Write <span class="math inline">\(\pi : TX \to X\)</span> for the projection map which sends <span class="math inline">\(T_xX\)</span> to <span class="math inline">\(x\)</span>. Assume that <span class="math inline">\(x_1,\dots,x_d\)</span> are coordinates on <span class="math inline">\(U \subseteq X\)</span>. Then we have a bundle chart <span class="math display">\[ \pi^{-1}(U) \ni \left( x, \sum a_i \frac{\partial}{\partial x_i} \lvert_x \right) 
\mapsto 
(x,(a_i)) \in U \times \mathbb{R}^d\]</span> Suppose that <span class="math inline">\(y_1,\dots,y_d\)</span> are coordinates on <span class="math inline">\(V \subseteq X\)</span>. Then <span class="math display">\[\frac{\partial}{\partial x_j}\lvert_x = \sum_i \frac{\partial y_i}{\partial x_j}(x) 
\frac{\partial}{\partial y_i} \lvert_x\]</span> Therefore the change of coordinates from <span class="math inline">\(U\)</span> to <span class="math inline">\(V\)</span>, <span class="math inline">\(\phi : U \cap V \to {\rm GL}_d(\mathbb{R})\)</span> is given by <span class="math display">\[\phi(x) = \left( \frac{\partial y_i}{\partial x_j}(x) \right)\]</span> Maybe you are worried that we did not prove that <span class="math inline">\(TX\)</span> was a manifold before we prove that it was a vector bundle. Everything is OK, because the vector bundle charts we have described on <span class="math inline">\(TX\)</span> are also plain old coordinate charts. We have defined a new type of mathematical object, so we need to define the morphisms. If <span class="math inline">\(E,F\)</span> are vector bundles over <span class="math inline">\(X\)</span> then a map of vector bundles <span class="math inline">\(f : E \to F\)</span> is a smooth map such that</p>
<ul>
<li><span class="math inline">\(\pi_F \circ f = \pi_E\)</span> (i.e <span class="math inline">\(f\)</span> maps fibers into fibers)</li>
<li><span class="math inline">\(f\)</span> is linear on the fibers.</li>
</ul>
<h3 id="gluing-data">Gluing Data</h3>
<p>Suppose that <span class="math inline">\(\pi : E \to X\)</span> is a vector bundle. Let <span class="math inline">\(X = \cup_{\alpha} U_{\alpha}\)</span> be an open cover such that each <span class="math inline">\(\pi^{-1}(U_{\alpha})\)</span> is a bundle chart on <span class="math inline">\(E\)</span>. Write <span class="math inline">\(\phi_{\beta\alpha} : U_{\alpha} \cap U_{\beta} \to {\rm GL}_r(\mathbb{R})\)</span> for the change of coordinates from <span class="math inline">\(\pi^{-1}(U_{\alpha})\)</span> to <span class="math inline">\(\pi^{-1}(U_{\beta})\)</span>. Then we have</p>
<ul>
<li><span class="math inline">\(\phi_{\alpha\alpha} = {\rm id}\)</span></li>
<li><span class="math inline">\(\phi_{\gamma\beta} \phi_{\beta\alpha} = \phi_{\gamma\alpha}\)</span> on <span class="math inline">\(U_{\alpha} \cap U_{\beta} \cap U_{\gamma}\)</span>.</li>
</ul>
<p>We call <span class="math inline">\((\phi_{\beta\alpha}, U_{\alpha})\)</span> gluing data for the vector bundle <span class="math inline">\(E\)</span>. From the gluing data we can reconstruct <span class="math inline">\(E\)</span>: The gluing data tells us where the vector bundle charts are and how to change coordinates between them. We can also describe vector bundle maps in terms of gluing data. Suppose that we have two vector bundles <span class="math inline">\(E\)</span> and <span class="math inline">\(F\)</span> described by gluing data <span class="math inline">\((\phi_{\beta\alpha},U_{\alpha})\)</span> and <span class="math inline">\((\psi_{\beta\alpha},U_{\alpha})\)</span>. Then a vector bundle morphism <span class="math inline">\(f : E \to F\)</span> consists of maps <span class="math inline">\(f_{\alpha} : U_{\alpha} \to {\rm Mat}_{s \times r}(\mathbb{R})\)</span> such that <span class="math display">\[\psi_{\beta\alpha} f_{\alpha} = f_{\beta} \phi_{\beta\alpha}\]</span> on <span class="math inline">\(U_{\alpha} \cap U_{\beta}\)</span>.</p>
<p>This definition is not without flaws. Suppose we write <span class="math inline">\(U_{\alpha} = \cup_p V_{\alpha, p}\)</span>. Then we get new gluing data<br />
<span class="math inline">\((\phi_{\beta,q,\alpha,p}, V_{\alpha,p})\)</span> defined by</p>
<ul>
<li><span class="math inline">\(\phi_{\alpha,q,\alpha,p} = {\rm id}\)</span></li>
<li><span class="math inline">\(\phi_{\beta,q,\alpha,p} = \phi_{\beta,\alpha} \lvert_{V_{\beta,q} \cap V_{\alpha,p}}\)</span>.</li>
</ul>
<p>This gluing data describes the same vector bundle as <span class="math inline">\((\phi_{\beta\alpha}, U_{\alpha})\)</span>, despite being defined over a different open cover of <span class="math inline">\(X\)</span>. Eventually, when we talk about sheaf cohomology, we will fix this problem, but for now we shall just work with the imperfect definition. In practice, this does not cause problems. If <span class="math inline">\(U \subseteq X\)</span> is a <a href="https://en.wikipedia.org/wiki/Contractible_space">contractible</a> coordinate chart, then <span class="math inline">\(\pi^{-1}(U)\)</span> is a vector bundle chart on <span class="math inline">\(E\)</span>. This is because every vector bundle over <span class="math inline">\(\mathbb{R}^d\)</span> is trivial. Therefore, with suitable choices of coordinates on the base, we get gluing data for every vector bundle with the same open cover.</p>
<h3 id="an-example">An Example</h3>
<p>We have seen that every manifold <span class="math inline">\(X\)</span> has a tangent bundle <span class="math inline">\(TX\)</span> and written down its gluing data. Let us work through another example to demonstrate how one works with vector bundles. Consider <span class="math inline">\(\mathbb{RP}^1\)</span>, the set of 1-dimensional subspaces of <span class="math inline">\(\mathbb{R}^2\)</span>. We write <span class="math inline">\([a:b]\)</span> for the line spanned by <span class="math inline">\((a,b)\)</span>. If <span class="math inline">\(X,Y\)</span> are linear coordinates on <span class="math inline">\(\mathbb{R}^2\)</span>, then <span class="math inline">\(X/Y\)</span> and <span class="math inline">\(Y/X\)</span> are smooth partial functions on <span class="math inline">\(\mathbb{RP}^1\)</span>. In high school mathematics, the function <span class="math inline">\(Y/X\)</span> is often called the gradient. We shall write <span class="math inline">\(m = Y/X\)</span>. We also write <span class="math inline">\(n = X/Y\)</span>. Then <span class="math inline">\(m = 1/n\)</span> were both functions are defined. Infact, if we set <span class="math display">\[ {\rm D}(X) = \{ L \in \mathbb{RP}^1 : X(L) \not= 0 \}\]</span> <span class="math display">\[ {\rm D}(Y) = \{ L \in \mathbb{RP}^1 : Y(L) \not= 0 \}\]</span> then <span class="math inline">\(\mathbb{RP}^1 = {\rm D}(X) \cup {\rm D}(Y)\)</span>, <span class="math inline">\(m = Y/X\)</span> is a coordinate on <span class="math inline">\({\rm D}(X)\)</span> and <span class="math inline">\(n = X/Y\)</span> is a coordinate on <span class="math inline">\({\rm D}(Y)\)</span>. Define <span class="math display">\[ L = \{ (p,L) \in \mathbb{R}^2 \times \mathbb{RP}^1 : p \in L \} \]</span> Then <span class="math inline">\(L\)</span> is a rank <span class="math inline">\(1\)</span> vector bundle (or a line bundle) over <span class="math inline">\(\mathbb{RP}^1\)</span>. Write <span class="math inline">\(\pi : L \to \mathbb{RP}^1\)</span> for the obvious projection. We have bundle coordinates <span class="math display">\[ (\lambda,m) \mapsto ( (\lambda,\lambda m),[1:m]) \quad \text{over ${\rm D}(X)$}\]</span> <span class="math display">\[ (\lambda,n) \mapsto ( (\lambda n,\lambda),[n:1]) \quad \text{over ${\rm D}(Y)$} \]</span> The change of coordinates map is <span class="math display">\[(\lambda,m) \mapsto ((\lambda,\lambda m),[1:m]) = ((\lambda m \frac{1}{m}, \lambda 
m), [1/m:1]) \mapsto (m \lambda, 1/m)\]</span> Therefore the change of coordinate map from <span class="math inline">\(D(X)\)</span> to <span class="math inline">\(D(Y)\)</span> is <span class="math inline">\(Y/X : D(X) \cap D(Y) \to \mathbb{R}^{\times}\)</span>. We don't need to worry about the cocycle condition because there are only two coordinate charts. We call <span class="math inline">\(L\)</span> the <em>tautological line bundle</em> over <span class="math inline">\(\mathbb{RP}^1\)</span>. Suppose that <span class="math inline">\(f : \mathbb{R}^2 \to \mathbb{R}\)</span> is a linear function. Then we have a bundle map <span class="math inline">\(f : L \to \mathbb{R} \times \mathbb{RP}^1\)</span> defined by <span class="math inline">\((p,L) \mapsto (f(p),L)\)</span>. If <span class="math inline">\(f = aX + bY\)</span>, then we have <span class="math display">\[ f = \left(a + b \frac{Y}{X}\right) \text{ over $D(X)$}\]</span> <span class="math display">\[ f = \left(a \frac{X}{Y} + b\right) \text{ over $D(Y)$}\]</span></p>
<h3 id="locally-free-sheaves">Locally free sheaves</h3>
<p>So far we have been describing vector bundles as manifolds over some base <span class="math inline">\(X\)</span> where all the fibers are vector spaces. There is also a sheaf theoretic definition of vector bundles which we shall explore in this section.</p>
<p>Let <span class="math inline">\(X = \mathbb{R}\)</span> and consider the vector bundle <span class="math inline">\(E = X \times \mathbb{R}\)</span>. We have a vector bundle map <span class="math inline">\(f : E \to E\)</span> defined by <span class="math inline">\((x,\lambda) \mapsto (x, x \lambda)\)</span>. We can think of <span class="math inline">\(f\)</span> as the matrix <span class="math inline">\((x)\)</span>. If we try and take the kernel of <span class="math inline">\(f\)</span>, something bad happens: The map <span class="math inline">\(f\)</span> is injective when <span class="math inline">\(x \not= 0\)</span> and zero when <span class="math inline">\(x=0\)</span>. Therefore the kernel should be like a vector bundle which is zero dimensional over <span class="math inline">\(\mathbb{R} \backslash \{ 0 \}\)</span> and one dimensional over <span class="math inline">\(\{ 0 \}\)</span>. Obviously, no such vector bundle exists. The reason we need the sheaf theoretic definition of vector bundle is because it gives us a meaningful way to assign kernels and cokernels to all vector bundle maps, not just those with constant rank.</p>
<p>Let <span class="math inline">\(X\)</span> be a manifold. Recall that <span class="math inline">\(\mathscr{C}\)</span> is the sheaf of smooth functions on <span class="math inline">\(X\)</span>. A <span class="math inline">\(\mathscr{C}\)</span>-module is a sheaf of abelian groups <span class="math inline">\(\mathscr{F}\)</span> such that each <span class="math inline">\(\mathscr{F}(U)\)</span> is a <span class="math inline">\(\mathscr{C}(U)\)</span>-module and the restriction maps are compatible with the <span class="math inline">\(\mathscr{C}\)</span>-action: <span class="math inline">\((s v) \lvert_V = s \lvert_V v \lvert_V\)</span>. Let <span class="math inline">\(\pi : E \to X\)</span> be a vector bundle. We can build a <span class="math inline">\(\mathscr{C}\)</span>-module <span class="math inline">\(\mathscr{E}\)</span> called the <em>sheaf of sections</em> as follows. If <span class="math inline">\(U \subseteq X\)</span> is open, then <span class="math inline">\(\mathscr{E}(U)\)</span> is the sections of <span class="math inline">\(E\)</span> over <span class="math inline">\(U\)</span>: <span class="math display">\[\mathscr{E}(U) = \{ s : U \to E : \pi s = {\rm id}_U \}\]</span> If <span class="math inline">\(s,t \in \mathscr{E}(U)\)</span> then we define <span class="math inline">\((s+t)(x) = s(x) + t(x)\)</span>. This makes sense because both <span class="math inline">\(s(x)\)</span> and <span class="math inline">\(t(x)\)</span> are vectors in the fiber <span class="math inline">\(\pi^{-1}(x)\)</span>. Therefore <span class="math inline">\(\mathscr{E}\)</span> is a presheaf of abelian groups. To check that <span class="math inline">\(\mathscr{E}\)</span> is a sheaf, you just need to unravel the definitions. If <span class="math inline">\(f \in \mathscr{C}(U)\)</span> and <span class="math inline">\(s \in \mathscr{E}(U)\)</span>, then we define <span class="math inline">\((fs)(x) = f(x) s(x)\)</span>. Therefore <span class="math inline">\(\mathscr{E}\)</span> is a <span class="math inline">\(\mathscr{C}\)</span>-module. The sheaf of sections <span class="math inline">\(\mathscr{E}\)</span> is much nicer than an arbitrary <span class="math inline">\(\mathscr{C}\)</span>-module. Indeed, <span class="math inline">\(\mathscr{E}\)</span> is a locally free <span class="math inline">\(\mathscr{C}\)</span>-module! This means that for each point <span class="math inline">\(p \in X\)</span>, there is a neighborhood <span class="math inline">\(p \in U\)</span> such that <span class="math inline">\(\mathscr{E}\lvert_U \cong \mathscr{C}_{U}^{\oplus r}\)</span>. To see this, choose a bundle chart <span class="math inline">\(\pi^{-1}(U) = U \times \mathbb{R}^r\)</span>. Write <span class="math inline">\(e_1,\dots,e_r\)</span> for the standard basis of <span class="math inline">\(\mathbb{R}^r\)</span>. Then <span class="math display">\[\mathscr{E}(U) = \{ f_1 e_1 + \dots + f_r e_r : f_i \in \mathscr{C}(U) \} \cong 
\mathscr{C}(U)^{\oplus r}.\]</span> To denote this, we shall write <span class="math inline">\(\mathscr{E}\lvert_U = \mathscr{C} \lvert_U \{ e_1,\dots,e_r \}\)</span>. The map <span class="math inline">\(E \mapsto \mathscr{E}\)</span> sends vector bundles to locally free sheaves. It is an amazing fact that every locally free sheaf arises this way! Suppose that <span class="math inline">\(\mathscr{F}\)</span> is a locally free sheaf. Suppose that <span class="math inline">\(\mathscr{F}\lvert_U = \mathscr{C} \lvert_U \{ s_1,\dots,s_r \}\)</span> and <span class="math inline">\(\mathscr{F} \lvert_V = \mathscr{C} \lvert_U \{ t_1,\dots,t_r \}\)</span>. Then the change of basis matrix from <span class="math inline">\(s_1,\dots,s_r\)</span> to <span class="math inline">\(t_1,\dots,t_r\)</span> is a smooth map <span class="math inline">\(\phi : U \cap V \to {\rm GL}_r(\mathbb{R})\)</span>. Moreover, if you do this over three open sets, then the cocycle condition is satisfied, so we can construct a vector bundle <span class="math inline">\(F\)</span> such that <span class="math inline">\(F \mapsto \mathscr{F}\)</span>. We can capture all of this in the following precise statement: The functor <span class="math inline">\(E \mapsto \mathscr{E}\)</span> from the category of vector bundles to the category of locally free sheaves is an <a href="https://en.wikipedia.org/wiki/Equivalence_of_categories">equivalence of categories</a>. Lets explore the map <span class="math inline">\(f : E \to E\)</span> from the start of the section using our new sheaf theoretic language. The sheaf of sections <span class="math inline">\(\mathscr{E}\)</span> is just <span class="math inline">\(\mathscr{C}\)</span>, the sheaf of smooth functions on <span class="math inline">\(X\)</span>. The induced map <span class="math inline">\(\mathscr{C} \to \mathscr{C}\)</span> is given by multiplication by <span class="math inline">\(x\)</span>. If <span class="math inline">\(f\)</span> is a smooth map and <span class="math inline">\(fx = 0\)</span> then <span class="math inline">\(f = 0\)</span> by continuity. Therefore the kernel of <span class="math inline">\(f\)</span> is the zero sheaf! What the heck? Shouldn't the kernel somehow represent a &quot;vector bundle&quot; which is zero over <span class="math inline">\(\mathbb{R} \backslash \{ 0 \}\)</span> and one dimensional over <span class="math inline">\(0\)</span>? The answer is no. We are simply taking the <a href="https://en.wikipedia.org/wiki/Kernel_%28category_theory">kernel</a> in the category of <span class="math inline">\(\mathscr{C}\)</span>-modules. If it doesn't behave how we expect, it is not the categories fault, it is our fault for working inside the wrong category. On the bright side, the cokernel of <span class="math inline">\(f\)</span> will represent a &quot;vector bundle&quot; which is 1-dimensional over <span class="math inline">\(0\)</span> and zero over <span class="math inline">\(\mathbb{R} \backslash \{ 0 \}\)</span>, but we need to talk about sheafification before we can talk about cokernels (we will do this in a later post).</p>
<h3 id="sections-of-the-tangent-bundle">Sections of the tangent bundle</h3>
<p>Let <span class="math inline">\(X\)</span> be a manifold. Write <span class="math inline">\(T\)</span> for the tangent bundle and <span class="math inline">\(\mathscr{T}\)</span> for the associated sheaf of sections. Elements in <span class="math inline">\(\mathscr{T}(X)\)</span> assign tangent vectors to each point in <span class="math inline">\(X\)</span>, so they are vector fields on <span class="math inline">\(X\)</span>. In <a href="2016-02-07-tangentspaces.html">the last post</a>, we proved that if <span class="math inline">\(x_i\)</span> are coordinates on <span class="math inline">\(U \subseteq X\)</span>, then <span class="math display">\[\mathscr{T} \lvert_U = \mathscr{C} \lvert_U \left\{ \frac{\partial}{\partial x_1}, 
\dots, \frac{\partial}{\partial x_d} \right\} \]</span> where <span class="math inline">\(\partial / \partial x_i\)</span> represents the section which sends <span class="math inline">\(x\)</span> to <span class="math inline">\(\partial / \partial x_i \lvert_x\)</span>. There is another way to describe the locally free sheaf <span class="math inline">\(\mathscr{T}\)</span> which is important. We can define a sheaf <span class="math inline">\({\rm Hom}_{\mathbb{R}}(\mathscr{C},\mathscr{C})\)</span> as follows: The sections over <span class="math inline">\(U\)</span> are the <span class="math inline">\(\mathbb{R}\)</span>-linear sheaf homomorphisms <span class="math inline">\(\mathscr{C} \lvert_U \to \mathscr{C} \lvert_U\)</span>. It is routine to check that the sheaf axioms are satisfied. Define <span class="math display">\[\mathscr{D} = \{ D \in {\rm Hom}_{\mathbb{R}}(\mathscr{C},\mathscr{C}) : D(fg) = f 
D(g) + g D(f) \}\]</span> This is the sheaf of first order differential operators. Pointwise multiplication turns <span class="math inline">\(\mathscr{D}\)</span> into a <span class="math inline">\(\mathscr{C}\)</span>-module. There is a map <span class="math inline">\(\mathscr{T} \to \mathscr{D}\)</span> defined by <span class="math inline">\(V \mapsto f \mapsto (x \mapsto V_x(f))\)</span>. Under this map, the vector field <span class="math inline">\(\partial / \partial x_i\)</span> is sent to partial differentiation with respect to <span class="math inline">\(x_i\)</span>. We can define the inverse map <span class="math inline">\(\mathscr{D} \to \mathscr{T}\)</span> by <span class="math inline">\(D \mapsto x \mapsto f \mapsto D(f)(x)\)</span>. It is routine to check that these maps establish an isomorphism of <span class="math inline">\(\mathscr{C}\)</span>-modules.</p>
<h3 id="exercises">Exercises</h3>
<ol style="list-style-type: decimal">
<li>write down gluing data for the tautological line bundle on <span class="math inline">\(\mathbb{RP}^n\)</span>.</li>
<li>Prove that <span class="math inline">\(E \mapsto \mathscr{E}\)</span> is an equivalence of categories between vector bundles and locally free sheaves.</li>
<li>Check that <span class="math inline">\({\rm Hom}(\mathscr{F},\mathscr{G})\)</span> is actually a sheaf.</li>
<li><strong>(Harder)</strong> Prove that every vector bundle over <span class="math inline">\(\mathbb{R}^d\)</span> is trivial.</li>
</ol>


  </body>
</html>
